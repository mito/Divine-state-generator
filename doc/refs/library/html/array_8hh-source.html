<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>DiVinE: array.hh Source File</title>
<link href="main.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
<h1>array.hh</h1><a href="array_8hh.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef DIVINE_ARRAY_HH</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define DIVINE_ARRAY_HH</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00013"></a>00013 <span class="preprocessor">#ifndef DOXYGEN_PROCESSING</span>
<a name="l00014"></a>00014 <span class="preprocessor"></span><span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;cstring&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include "<a class="code" href="error_8hh.html">common/error.hh</a>"</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include "common/types.hh"</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include "common/deb.hh"</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="keyword">namespace </span>divine { <span class="comment">//We want Doxygen not to see namespace `dve'</span>
<a name="l00021"></a>00021 <span class="keyword">using</span> std::cerr; <span class="keyword">using</span> std::endl;
<a name="l00022"></a>00022 <span class="preprocessor">#endif //DOXYGEN_PROCESSING</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span>
<a name="l00024"></a>00024 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00025"></a>00025 T * default_new_field_of_objects(<span class="keyword">const</span> size_int_t count)
<a name="l00026"></a>00026 { 
<a name="l00027"></a>00027   <span class="keywordflow">return</span> (<span class="keyword">new</span> T[count]); 
<a name="l00028"></a>00028 }
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 
<a name="l00032"></a>00032 
<a name="l00057"></a>00057 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, T* (*Alloc)(const size_<span class="keywordtype">int</span>_t count) = default_new_field_of_<span class="keywordtype">object</span>s&lt;T&gt; &gt;
<a name="l00058"></a><a class="code" href="classarray__t.html">00058</a> <span class="keyword">class </span><a class="code" href="classarray__t.html" title="Simple resizable container representing 1-dimensional array.">array_t</a>
<a name="l00059"></a>00059 {
<a name="l00060"></a>00060  <span class="keyword">private</span>:
<a name="l00061"></a>00061   size_int_t allocated;
<a name="l00062"></a>00062   size_int_t alloc_step;
<a name="l00063"></a>00063   size_int_t my_size;
<a name="l00064"></a>00064  <span class="keyword">protected</span>:
<a name="l00066"></a><a class="code" href="classarray__t.html#38b8e939186b88e109d2b33b627451be">00066</a>   T * field;
<a name="l00067"></a>00067  <span class="keyword">public</span>:
<a name="l00069"></a>00069 
<a name="l00071"></a><a class="code" href="classarray__t.html#35c955cacac6aacaa1e82874b1628865">00071</a>   <span class="keyword">typedef</span> T * <a class="code" href="classdve__symbol__t.html">iterator</a>;
<a name="l00073"></a>00073 
<a name="l00076"></a><a class="code" href="classarray__t.html#2fc97dce62b7053449cc868607540dba">00076</a>   <span class="keyword">typedef</span> <span class="keyword">const</span> T * <a class="code" href="classdve__symbol__t.html">const_iterator</a>;
<a name="l00078"></a>00078 
<a name="l00079"></a><a class="code" href="classarray__t.html#d69bd11391be1a1dba5c8202259664f8">00079</a>   <a class="code" href="classdve__symbol__t.html">iterator</a> begin() { <span class="keywordflow">return</span> &amp;field[0]; }
<a name="l00082"></a>00082 
<a name="l00083"></a><a class="code" href="classarray__t.html#cad38d52497a975bfb6f2f6acd76631f">00083</a>   <a class="code" href="classdve__symbol__t.html">iterator</a> end() { <span class="keywordflow">return</span> &amp;field[my_size]; }
<a name="l00085"></a>00085 
<a name="l00086"></a><a class="code" href="classarray__t.html#4f73d0c8e4ea8066dbc54a6a63330252">00086</a>   <a class="code" href="classdve__symbol__t.html">iterator</a> last() { <span class="keywordflow">return</span> &amp;field[my_size-1]; }
<a name="l00088"></a>00088 
<a name="l00089"></a><a class="code" href="classarray__t.html#a4b02d4f1a8500fb07a551069060709f">00089</a>   <a class="code" href="classdve__symbol__t.html">const_iterator</a> begin()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;field[0]; }
<a name="l00092"></a>00092 
<a name="l00093"></a><a class="code" href="classarray__t.html#350132543d80a1c1e5be844e6d2878ea">00093</a>   <a class="code" href="classdve__symbol__t.html">const_iterator</a> end()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;field[my_size]; }
<a name="l00095"></a>00095 
<a name="l00096"></a><a class="code" href="classarray__t.html#bb8e6ce01e2629c199ffc9405bba2a7c">00096</a>   <a class="code" href="classdve__symbol__t.html">const_iterator</a> last()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;field[my_size-1]; }
<a name="l00098"></a>00098 
<a name="l00102"></a><a class="code" href="classarray__t.html#bbf40a10f7a4adf7a296830bb09f8e2f">00102</a>   <span class="keywordtype">void</span> assign_from(<span class="keyword">const</span> <a class="code" href="classarray__t.html" title="Simple resizable container representing 1-dimensional array.">array_t&lt;T, Alloc&gt;</a> &amp; to_copy)
<a name="l00103"></a>00103    {
<a name="l00104"></a>00104     DEBFUNC(cerr &lt;&lt; <span class="stringliteral">"BEGIN of array_t&lt;T&gt;::assign_from"</span> &lt;&lt; endl;)
<a name="l00105"></a>00105     my_size = to_copy.<a class="code" href="classarray__t.html#2216cf611d64e85907f4a64977f251e1" title="Returns a count of items stored in a container.">size</a>();
<a name="l00106"></a>00106     alloc_step = to_copy.<a class="code" href="classarray__t.html#58a09d8ac91970e7eec713b6dcbd42f7" title="Returns an allocation step.">get_alloc_step</a>();
<a name="l00107"></a>00107     allocated = to_copy.<a class="code" href="classarray__t.html#4fd2c8aafffc98cd5cd8be9edb49790d" title="Returns a count of items allocated in a memory of this container.">get_allocated</a>();
<a name="l00108"></a>00108     <span class="keywordflow">if</span> (field) <span class="keyword">delete</span> [] field;
<a name="l00109"></a>00109     field = allocated ? Alloc(allocated) : 0;
<a name="l00110"></a>00110     <span class="keywordflow">for</span> (size_int_t i = 0; i!=my_size; ++i)
<a name="l00111"></a>00111       field[i] = to_copy[i];
<a name="l00112"></a>00112     DEBFUNC(cerr &lt;&lt; <span class="stringliteral">"END of array_t&lt;T&gt;::assign_from"</span> &lt;&lt; endl;)
<a name="l00113"></a>00113    }
<a name="l00115"></a>00115 
<a name="l00118"></a><a class="code" href="classarray__t.html#58e5868f2bf2c723cbf9be8252c6aec1">00118</a>   <a class="code" href="classarray__t.html" title="Simple resizable container representing 1-dimensional array.">array_t</a>(size_int_t allocate = 2, size_int_t step = 2)
<a name="l00119"></a>00119    {
<a name="l00120"></a>00120     allocated = allocate; alloc_step = step; my_size = 0;
<a name="l00121"></a>00121     field = allocated ? Alloc(allocated) : 0;
<a name="l00122"></a>00122    }
<a name="l00124"></a>00124   <span class="comment">/* It is implemented using assign_from() method, therefor it takes</span>
<a name="l00125"></a>00125 <span class="comment">   * both time and memory &lt;i&gt;O(n)&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is</span>
<a name="l00126"></a>00126 <span class="comment">   * a number of items in \a to_copy instance of the container.*/</span>
<a name="l00127"></a><a class="code" href="classarray__t.html#8a03d6ea176d1cce3cf527c520f2b8d2">00127</a>   <a class="code" href="classarray__t.html" title="Simple resizable container representing 1-dimensional array.">array_t</a>(<span class="keyword">const</span> <a class="code" href="classarray__t.html" title="Simple resizable container representing 1-dimensional array.">array_t&lt;T, Alloc&gt;</a> &amp; to_copy)
<a name="l00128"></a>00128   { field = 0; assign_from(to_copy); }
<a name="l00130"></a><a class="code" href="classarray__t.html#56841a66cd380197d933af231ebd4ea5">00130</a>   ~<a class="code" href="classarray__t.html" title="Simple resizable container representing 1-dimensional array.">array_t</a>() { <span class="keywordflow">if</span> (field) <span class="keyword">delete</span> [] field; }
<a name="l00132"></a>00132 
<a name="l00136"></a><a class="code" href="classarray__t.html#6ca947f3c87573111ff4a96a97042477">00136</a>   <span class="keywordtype">void</span> push_back(T what)
<a name="l00137"></a>00137    {
<a name="l00138"></a>00138     <span class="keywordflow">if</span> (my_size&lt;allocated) { field[my_size] = what; ++my_size; }
<a name="l00139"></a>00139     <span class="keywordflow">else</span> { extend(1); field[my_size-1] = what; }
<a name="l00140"></a>00140    }
<a name="l00142"></a>00142 
<a name="l00146"></a><a class="code" href="classarray__t.html#73649441c9e19846aa9da9a2b214e03e">00146</a>   T pop_back()
<a name="l00147"></a>00147    { my_size--; <span class="keywordflow">return</span> field[my_size]; }
<a name="l00149"></a>00149 
<a name="l00154"></a><a class="code" href="classarray__t.html#9821feac13831e832c3447a3a333a9f9">00154</a>   <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_int_t count)
<a name="l00155"></a>00155   { <span class="keywordflow">if</span> (count&lt;=my_size) shrink_to(count); <span class="keywordflow">else</span> extend_to(count); }
<a name="l00157"></a>00157 
<a name="l00161"></a><a class="code" href="classarray__t.html#d0e444e6c65888495eec136774166dc7">00161</a>   <span class="keywordtype">void</span> shrink_to(<span class="keyword">const</span> size_int_t count)
<a name="l00162"></a>00162   { my_size = count; }
<a name="l00164"></a>00164 
<a name="l00169"></a><a class="code" href="classarray__t.html#c88da080a0faf84f35473285eed38b26">00169</a>   <span class="keywordtype">void</span> extend_to(<span class="keyword">const</span> size_int_t count)
<a name="l00170"></a>00170   { extend(count-my_size); }
<a name="l00172"></a>00172 
<a name="l00176"></a><a class="code" href="classarray__t.html#6100ef16bd8c2b2446f7d8922e6d8257">00176</a>   <span class="keywordtype">void</span> extend(<span class="keyword">const</span> size_int_t count)
<a name="l00177"></a>00177    {
<a name="l00178"></a>00178     <span class="keywordflow">if</span> ((my_size + count) &gt; allocated)
<a name="l00179"></a>00179      {
<a name="l00180"></a>00180       allocated = (((my_size+count) / alloc_step) + 1)*alloc_step;
<a name="l00181"></a>00181       DEB(cerr &lt;&lt; <span class="stringliteral">"Newly allocated "</span> &lt;&lt; allocated &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; <span class="keyword">sizeof</span>(T))
<a name="l00182"></a>00182       DEB(     &lt;&lt; <span class="stringliteral">"-bytes"</span> &lt;&lt; endl;)
<a name="l00183"></a>00183       T * aux_pointer = Alloc(allocated);
<a name="l00184"></a>00184       <span class="keywordflow">if</span> (field)
<a name="l00185"></a>00185        {
<a name="l00186"></a>00186         memcpy(aux_pointer,field,my_size*<span class="keyword">sizeof</span>(T));
<a name="l00187"></a>00187         <span class="keyword">delete</span> [] field;
<a name="l00188"></a>00188        }
<a name="l00189"></a>00189       field = aux_pointer;
<a name="l00190"></a>00190      }
<a name="l00191"></a>00191     my_size += count;
<a name="l00192"></a>00192    }
<a name="l00194"></a><a class="code" href="classarray__t.html#2216cf611d64e85907f4a64977f251e1">00194</a>   size_int_t size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> my_size; }
<a name="l00196"></a>00196 
<a name="l00198"></a><a class="code" href="classarray__t.html#4fd2c8aafffc98cd5cd8be9edb49790d">00198</a>   size_int_t get_allocated()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> allocated; }
<a name="l00200"></a>00200 
<a name="l00203"></a><a class="code" href="classarray__t.html#58a09d8ac91970e7eec713b6dcbd42f7">00203</a>   size_int_t get_alloc_step()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> alloc_step; }
<a name="l00205"></a>00205 
<a name="l00208"></a><a class="code" href="classarray__t.html#643855ce67fbf1d69755427f63acc2bf">00208</a>   <span class="keywordtype">void</span> set_alloc_step(<span class="keyword">const</span> size_int_t new_alloc_step)
<a name="l00209"></a>00209     { alloc_step = new_alloc_step; }
<a name="l00211"></a><a class="code" href="classarray__t.html#55d9a449187445866021859f0cf708d0">00211</a>   T &amp; front() { <span class="keywordflow">return</span> field[0]; }
<a name="l00213"></a><a class="code" href="classarray__t.html#33144bdb055f125014515b05fffaea8e">00213</a>   <span class="keyword">const</span> T &amp; front()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> field[0]; }
<a name="l00215"></a><a class="code" href="classarray__t.html#94c484819f66b605343298653d4b1d07">00215</a>   T &amp; back() { <span class="keywordflow">return</span> field[my_size-1]; }
<a name="l00217"></a><a class="code" href="classarray__t.html#66ff8d365d8820194730f759978dc1d0">00217</a>   <span class="keyword">const</span> T &amp; back()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> field[my_size-1]; }
<a name="l00219"></a><a class="code" href="classarray__t.html#207facaaa8c14c461113bd03ad23703b">00219</a>   T &amp; operator[](<span class="keyword">const</span> size_int_t i)
<a name="l00220"></a>00220     { DEBCHECK(<span class="keywordflow">if</span> (i&gt;=my_size) <a class="code" href="error_8hh.html#0dc53778a7848e90e519edb70273ebf6" title="Global error vector `gerr&amp;#39;.">gerr</a> &lt;&lt; <span class="stringliteral">"Indexing error"</span> &lt;&lt; <a class="code" href="structthr.html" title="Structure determined for causing storing/printing error messages.">thr</a>();)
<a name="l00221"></a>00221       <span class="keywordflow">return</span> field[i]; }
<a name="l00223"></a><a class="code" href="classarray__t.html#3c1a01cf6c60eac71bce2f4352d0f860">00223</a>   <span class="keyword">const</span> T &amp; operator[](<span class="keyword">const</span> size_int_t i)<span class="keyword"> const</span>
<a name="l00224"></a>00224 <span class="keyword">    </span>{ DEBCHECK(<span class="keywordflow">if</span> (i&gt;=my_size) <a class="code" href="error_8hh.html#0dc53778a7848e90e519edb70273ebf6" title="Global error vector `gerr&amp;#39;.">gerr</a> &lt;&lt; <span class="stringliteral">"Indexing error"</span> &lt;&lt; <a class="code" href="structthr.html" title="Structure determined for causing storing/printing error messages.">thr</a>();)
<a name="l00225"></a>00225       <span class="keywordflow">return</span> field[i]; }
<a name="l00227"></a>00227 
<a name="l00231"></a><a class="code" href="classarray__t.html#a0233442c8a81e376c9aa0e7f43b277e">00231</a>   <span class="keywordtype">void</span> swap(<a class="code" href="classarray__t.html" title="Simple resizable container representing 1-dimensional array.">array_t&lt;T, Alloc&gt;</a> &amp; second)
<a name="l00232"></a>00232    {
<a name="l00233"></a>00233     DEBFUNC(cerr &lt;&lt; <span class="stringliteral">"array_t&lt;T&gt;::swap called"</span> &lt;&lt; endl;)
<a name="l00234"></a>00234     
<a name="l00235"></a>00235     T * aux_pointer = field;
<a name="l00236"></a>00236     field = second.<a class="code" href="classarray__t.html#38b8e939186b88e109d2b33b627451be" title="The entire field of objects stored in array_t.">field</a>;
<a name="l00237"></a>00237     second.<a class="code" href="classarray__t.html#38b8e939186b88e109d2b33b627451be" title="The entire field of objects stored in array_t.">field</a> = aux_pointer;
<a name="l00238"></a>00238 
<a name="l00239"></a>00239     size_int_t aux;
<a name="l00240"></a>00240     aux = allocated; allocated = second.<a class="code" href="classarray__t.html#8d903c51a3a14533ab373b56883f81ea">allocated</a>; second.<a class="code" href="classarray__t.html#8d903c51a3a14533ab373b56883f81ea">allocated</a> = aux;
<a name="l00241"></a>00241     aux = alloc_step; alloc_step = second.<a class="code" href="classarray__t.html#506053542387697e61fe697cb7ea962f">alloc_step</a>; second.<a class="code" href="classarray__t.html#506053542387697e61fe697cb7ea962f">alloc_step</a> = aux;
<a name="l00242"></a>00242     aux = my_size; my_size = second.<a class="code" href="classarray__t.html#c143a53724aa486e48653d549c17c51a">my_size</a>; second.<a class="code" href="classarray__t.html#c143a53724aa486e48653d549c17c51a">my_size</a> = aux;
<a name="l00243"></a>00243    }
<a name="l00245"></a>00245 
<a name="l00247"></a><a class="code" href="classarray__t.html#c8bb3912a3ce86b15842e79d0b421204">00247</a>   <span class="keywordtype">void</span> clear() { my_size = 0; }
<a name="l00248"></a>00248 
<a name="l00256"></a>00256 };
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 
<a name="l00259"></a>00259 <span class="preprocessor">#ifndef DOXYGEN_PROCESSING</span>
<a name="l00260"></a>00260 <span class="preprocessor"></span>} <span class="comment">//end of namespace</span>
<a name="l00261"></a>00261 <span class="preprocessor">#include "common/undeb.hh"</span>
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 <span class="preprocessor">#endif //DOXYGEN_PROCESSING</span>
<a name="l00264"></a>00264 <span class="preprocessor"></span>
<a name="l00265"></a>00265 <span class="preprocessor">#endif</span>
<a name="l00266"></a>00266 <span class="preprocessor"></span>
</pre></div></div>

<hr size="1"><small><img align="center" src="divine_mini.gif"><b> Reference Manual for Library, 2006 developed in <a href="http://www.fi.muni.cz/paradise/">ParaDiSe</a> laboratory, <a href="http://www.fi.muni.cz/">Faculty of Informatics</a>, <a href="http://www.muni.cz/">Masaryk University</a></b></small>
</body>
</html>


