<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>DiVinE: array_t Class Template Reference</title>
<link href="main.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>array_t Class Template Reference</h1><!-- doxytag: class="array_t" -->Simple resizable container representing 1-dimensional array.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="array_8hh-source.html">array.hh</a>&gt;</code>
<p>

<p>
<a href="classarray__t-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef const T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#2fc97dce62b7053449cc868607540dba">const_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant iterator.  <a href="#2fc97dce62b7053449cc868607540dba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#35c955cacac6aacaa1e82874b1628865">iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator.  <a href="#35c955cacac6aacaa1e82874b1628865"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8a03d6ea176d1cce3cf527c520f2b8d2"></a><!-- doxytag: member="array_t::array_t" ref="8a03d6ea176d1cce3cf527c520f2b8d2" args="(const array_t&lt; T, Alloc &gt; &amp;to_copy)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#8a03d6ea176d1cce3cf527c520f2b8d2">array_t</a> (const <a class="el" href="classarray__t.html">array_t</a>&lt; T, Alloc &gt; &amp;to_copy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A copy constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#58e5868f2bf2c723cbf9be8252c6aec1">array_t</a> (size_int_t allocate=2, size_int_t step=2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A constructor.  <a href="#58e5868f2bf2c723cbf9be8252c6aec1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#bbf40a10f7a4adf7a296830bb09f8e2f">assign_from</a> (const <a class="el" href="classarray__t.html">array_t</a>&lt; T, Alloc &gt; &amp;to_copy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies `to_copy' to this container.  <a href="#bbf40a10f7a4adf7a296830bb09f8e2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="66ff8d365d8820194730f759978dc1d0"></a><!-- doxytag: member="array_t::back" ref="66ff8d365d8820194730f759978dc1d0" args="() const " -->
const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#66ff8d365d8820194730f759978dc1d0">back</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a constant reference to the last item in the container. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="94c484819f66b605343298653d4b1d07"></a><!-- doxytag: member="array_t::back" ref="94c484819f66b605343298653d4b1d07" args="()" -->
T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#94c484819f66b605343298653d4b1d07">back</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reference to the last item in the container. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classarray__t.html#2fc97dce62b7053449cc868607540dba">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#a4b02d4f1a8500fb07a551069060709f">begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a constant iterator pointing to the first item of the container.  <a href="#a4b02d4f1a8500fb07a551069060709f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classarray__t.html#35c955cacac6aacaa1e82874b1628865">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#d69bd11391be1a1dba5c8202259664f8">begin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an iterator pointing to the first item of the container.  <a href="#d69bd11391be1a1dba5c8202259664f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#c8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lowers the size of array to zero, but does not release allocated memory.  <a href="#c8bb3912a3ce86b15842e79d0b421204"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classarray__t.html#2fc97dce62b7053449cc868607540dba">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#350132543d80a1c1e5be844e6d2878ea">end</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classarray__t.html#35c955cacac6aacaa1e82874b1628865">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#cad38d52497a975bfb6f2f6acd76631f">end</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#6100ef16bd8c2b2446f7d8922e6d8257">extend</a> (const size_int_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extends the container <b>by</b> count members.  <a href="#6100ef16bd8c2b2446f7d8922e6d8257"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#c88da080a0faf84f35473285eed38b26">extend_to</a> (const size_int_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extends the container to the size of `count' elements.  <a href="#c88da080a0faf84f35473285eed38b26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="33144bdb055f125014515b05fffaea8e"></a><!-- doxytag: member="array_t::front" ref="33144bdb055f125014515b05fffaea8e" args="() const " -->
const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#33144bdb055f125014515b05fffaea8e">front</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a constant reference to the first item in the container. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="55d9a449187445866021859f0cf708d0"></a><!-- doxytag: member="array_t::front" ref="55d9a449187445866021859f0cf708d0" args="()" -->
T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#55d9a449187445866021859f0cf708d0">front</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reference to the first item in the container. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#58a09d8ac91970e7eec713b6dcbd42f7">get_alloc_step</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an allocation step.  <a href="#58a09d8ac91970e7eec713b6dcbd42f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#4fd2c8aafffc98cd5cd8be9edb49790d">get_allocated</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a count of items allocated in a memory of this container.  <a href="#4fd2c8aafffc98cd5cd8be9edb49790d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classarray__t.html#2fc97dce62b7053449cc868607540dba">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#bb8e6ce01e2629c199ffc9405bba2a7c">last</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a constant iterator pointing to the last item of the container.  <a href="#bb8e6ce01e2629c199ffc9405bba2a7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classarray__t.html#35c955cacac6aacaa1e82874b1628865">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#4f73d0c8e4ea8066dbc54a6a63330252">last</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an iterator pointing to the last item of the container.  <a href="#4f73d0c8e4ea8066dbc54a6a63330252"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3c1a01cf6c60eac71bce2f4352d0f860"></a><!-- doxytag: member="array_t::operator[]" ref="3c1a01cf6c60eac71bce2f4352d0f860" args="(const size_int_t i) const " -->
const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#3c1a01cf6c60eac71bce2f4352d0f860">operator[]</a> (const size_int_t i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a constant reference to `i'-th item in the container. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="207facaaa8c14c461113bd03ad23703b"></a><!-- doxytag: member="array_t::operator[]" ref="207facaaa8c14c461113bd03ad23703b" args="(const size_int_t i)" -->
T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#207facaaa8c14c461113bd03ad23703b">operator[]</a> (const size_int_t i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reference to `i'-th item in the container. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#73649441c9e19846aa9da9a2b214e03e">pop_back</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the last item from the container.  <a href="#73649441c9e19846aa9da9a2b214e03e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#6ca947f3c87573111ff4a96a97042477">push_back</a> (T what)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends `what' to the end of the container.  <a href="#6ca947f3c87573111ff4a96a97042477"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#9821feac13831e832c3447a3a333a9f9">resize</a> (const size_int_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resizes the container to the size of `count' elements.  <a href="#9821feac13831e832c3447a3a333a9f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#643855ce67fbf1d69755427f63acc2bf">set_alloc_step</a> (const size_int_t new_alloc_step)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an alloc_step step.  <a href="#643855ce67fbf1d69755427f63acc2bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#d0e444e6c65888495eec136774166dc7">shrink_to</a> (const size_int_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shrinks the container to the size of `count' elements.  <a href="#d0e444e6c65888495eec136774166dc7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2216cf611d64e85907f4a64977f251e1"></a><!-- doxytag: member="array_t::size" ref="2216cf611d64e85907f4a64977f251e1" args="() const " -->
size_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#2216cf611d64e85907f4a64977f251e1">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a count of items stored in a container. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#a0233442c8a81e376c9aa0e7f43b277e">swap</a> (<a class="el" href="classarray__t.html">array_t</a>&lt; T, Alloc &gt; &amp;second)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps the containment of instance `second' and this.  <a href="#a0233442c8a81e376c9aa0e7f43b277e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="56841a66cd380197d933af231ebd4ea5"></a><!-- doxytag: member="array_t::~array_t" ref="56841a66cd380197d933af231ebd4ea5" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#56841a66cd380197d933af231ebd4ea5">~array_t</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A destructor. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="38b8e939186b88e109d2b33b627451be"></a><!-- doxytag: member="array_t::field" ref="38b8e939186b88e109d2b33b627451be" args="" -->
T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray__t.html#38b8e939186b88e109d2b33b627451be">field</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The entire field of objects stored in <a class="el" href="classarray__t.html" title="Simple resizable container representing 1-dimensional array.">array_t</a>. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T, T *(*)(const size_int_t count) Alloc = default_new_field_of_objects&lt;T&gt;&gt;<br>
 class array_t&lt; T, Alloc &gt;</h3>

Simple resizable container representing 1-dimensional array. 
<p>
This container implement a resizable 1-dimensional array of a choosen type. The access to the single item of an array is implemented simply using operator [].<p>
Constraints imposed on type that can be paramater of this template: Type must not have contructor or destructor. It should be a scalar type like integer, pointer, etc.<p>
You can do reallocation using methods <a class="el" href="classarray__t.html#9821feac13831e832c3447a3a333a9f9" title="Resizes the container to the size of `count&#39; elements.">resize()</a>, <a class="el" href="classarray__t.html#d0e444e6c65888495eec136774166dc7" title="Shrinks the container to the size of `count&#39; elements.">shrink_to()</a>, <a class="el" href="classarray__t.html#c88da080a0faf84f35473285eed38b26" title="Extends the container to the size of `count&#39; elements.">extend_to()</a>, <a class="el" href="classarray__t.html#6100ef16bd8c2b2446f7d8922e6d8257" title="Extends the container by count members.">extend()</a> or <a class="el" href="classarray__t.html#6ca947f3c87573111ff4a96a97042477" title="Appends `what&#39; to the end of the container.">push_back()</a>.<p>
The purpose of this container is to implement container with really fast random access times to it. The penalty for the really fast read/write operations is a possibly slow realocation. Reallocation is implemented such way that if the container has not allocated sufficiently large memory, reallocation methods <a class="el" href="classarray__t.html#9821feac13831e832c3447a3a333a9f9" title="Resizes the container to the size of `count&#39; elements.">resize()</a>, <a class="el" href="classarray__t.html#6100ef16bd8c2b2446f7d8922e6d8257" title="Extends the container by count members.">extend()</a>, <a class="el" href="classarray__t.html#c88da080a0faf84f35473285eed38b26" title="Extends the container to the size of `count&#39; elements.">extend_to()</a> or <a class="el" href="classarray__t.html#6ca947f3c87573111ff4a96a97042477" title="Appends `what&#39; to the end of the container.">push_back()</a> allocate a larger piece of memory. It means that <a class="el" href="classarray__t.html#9821feac13831e832c3447a3a333a9f9" title="Resizes the container to the size of `count&#39; elements.">resize()</a>, <a class="el" href="classarray__t.html#6100ef16bd8c2b2446f7d8922e6d8257" title="Extends the container by count members.">extend()</a>, <a class="el" href="classarray__t.html#c88da080a0faf84f35473285eed38b26" title="Extends the container to the size of `count&#39; elements.">extend_to()</a> and <a class="el" href="classarray__t.html#6ca947f3c87573111ff4a96a97042477" title="Appends `what&#39; to the end of the container.">push_back()</a> may have time complexity <em>O(n)</em>, where <em>n</em> is a number items in an array. You can influence how often the array will be reallocated using <a class="el" href="classarray__t.html#643855ce67fbf1d69755427f63acc2bf" title="Sets an alloc_step step.">set_alloc_step()</a> method.<p>
There are defined functions <a class="el" href="classarray__t.html#a0233442c8a81e376c9aa0e7f43b277e" title="Swaps the containment of instance `second&#39; and this.">swap()</a> and <a class="el" href="classarray__t.html#bbf40a10f7a4adf7a296830bb09f8e2f" title="Copies `to_copy&#39; to this container.">assign_from()</a> to copy the contents of one instace of the container to another instance. <hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="2fc97dce62b7053449cc868607540dba"></a><!-- doxytag: member="array_t::const_iterator" ref="2fc97dce62b7053449cc868607540dba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classarray__t.html#2fc97dce62b7053449cc868607540dba">const_iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constant iterator. 
<p>
Constant iterator - you cannot change the value to which the iterator points. Dereferencing, increasing and descresing takes time <em>O(1)</em> and it is really fast. 
</div>
</div><p>
<a class="anchor" name="35c955cacac6aacaa1e82874b1628865"></a><!-- doxytag: member="array_t::iterator" ref="35c955cacac6aacaa1e82874b1628865" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classarray__t.html#35c955cacac6aacaa1e82874b1628865">iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterator. 
<p>
Iterator. Dereferencing, increasing and descresing takes time <em>O(1)</em> and it is really fast. 
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="58e5868f2bf2c723cbf9be8252c6aec1"></a><!-- doxytag: member="array_t::array_t" ref="58e5868f2bf2c723cbf9be8252c6aec1" args="(size_int_t allocate=2, size_int_t step=2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray__t.html">array_t</a>           </td>
          <td>(</td>
          <td class="paramtype">size_int_t&nbsp;</td>
          <td class="paramname"> <em>allocate</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_int_t&nbsp;</td>
          <td class="paramname"> <em>step</em> = <code>2</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>allocate</em>&nbsp;</td><td>= the number of items to pre-alllocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>step</em>&nbsp;</td><td>= the step of allocation in case of extending the container </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="bbf40a10f7a4adf7a296830bb09f8e2f"></a><!-- doxytag: member="array_t::assign_from" ref="bbf40a10f7a4adf7a296830bb09f8e2f" args="(const array_t&lt; T, Alloc &gt; &amp;to_copy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assign_from           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__t.html">array_t</a>&lt; T, Alloc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>to_copy</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies `to_copy' to this container. 
<p>
Copies the entrire contents of one instance of container to another one.<p>
This operation takes both memory and time <em>O(n)</em>, where <em>n</em> is a number of items in <em>to_copy</em> instance of the container. 
</div>
</div><p>
<a class="anchor" name="a4b02d4f1a8500fb07a551069060709f"></a><!-- doxytag: member="array_t::begin" ref="a4b02d4f1a8500fb07a551069060709f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray__t.html#2fc97dce62b7053449cc868607540dba">const_iterator</a> begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a constant iterator pointing to the first item of the container. 
<p>
It is really fast operation running in time <em>O(1)</em> 
</div>
</div><p>
<a class="anchor" name="d69bd11391be1a1dba5c8202259664f8"></a><!-- doxytag: member="array_t::begin" ref="d69bd11391be1a1dba5c8202259664f8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray__t.html#35c955cacac6aacaa1e82874b1628865">iterator</a> begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an iterator pointing to the first item of the container. 
<p>
It is really fast operation running in time <em>O(1)</em> 
<p>Referenced by <a class="el" href="dve__explicit__system_8cc-source.html#l01024">dve_explicit_system_t::get_sync_succs_internal()</a>, and <a class="el" href="dve__transition_8cc-source.html#l00019">dve_transition_t::~dve_transition_t()</a>.</p>

</div>
</div><p>
<a class="anchor" name="c8bb3912a3ce86b15842e79d0b421204"></a><!-- doxytag: member="array_t::clear" ref="c8bb3912a3ce86b15842e79d0b421204" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lowers the size of array to zero, but does not release allocated memory. 
<p>
Lowers the size of array to zero, but does not release allocated memory. It is the same as <code>shrink_to(0)</code>. 
<p>Referenced by <a class="el" href="dve__explicit__system_8cc-source.html#l00835">dve_explicit_system_t::get_async_enabled_trans_succs()</a>, <a class="el" href="dve__prob__explicit__system_8cc-source.html#l00007">dve_prob_explicit_system_t::get_succs()</a>, <a class="el" href="bymoc__explicit__system_8cc-source.html#l00087">bymoc_explicit_system_t::get_succs()</a>, <a class="el" href="dve__explicit__system_8cc-source.html#l00653">dve_explicit_system_t::get_sync_enabled_trans()</a>, <a class="el" href="dve__explicit__system_8cc-source.html#l01024">dve_explicit_system_t::get_sync_succs_internal()</a>, <a class="el" href="dve__transition_8cc-source.html#l00107">dve_transition_t::read()</a>, and <a class="el" href="dve__prob__transition_8cc-source.html#l00051">dve_prob_transition_t::read()</a>.</p>

</div>
</div><p>
<a class="anchor" name="350132543d80a1c1e5be844e6d2878ea"></a><!-- doxytag: member="array_t::end" ref="350132543d80a1c1e5be844e6d2878ea" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray__t.html#2fc97dce62b7053449cc868607540dba">const_iterator</a> end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a constant iterator pointing immediatelly behind the last item of the container<p>
It is really fast operation running in time <em>O(1)</em> 
</div>
</div><p>
<a class="anchor" name="cad38d52497a975bfb6f2f6acd76631f"></a><!-- doxytag: member="array_t::end" ref="cad38d52497a975bfb6f2f6acd76631f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray__t.html#35c955cacac6aacaa1e82874b1628865">iterator</a> end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an iterator pointing immediatelly behind the last item of the container<p>
It is really fast operation running in time <em>O(1)</em> 
<p>Referenced by <a class="el" href="dve__explicit__system_8cc-source.html#l01024">dve_explicit_system_t::get_sync_succs_internal()</a>, and <a class="el" href="dve__transition_8cc-source.html#l00019">dve_transition_t::~dve_transition_t()</a>.</p>

</div>
</div><p>
<a class="anchor" name="6100ef16bd8c2b2446f7d8922e6d8257"></a><!-- doxytag: member="array_t::extend" ref="6100ef16bd8c2b2446f7d8922e6d8257" args="(const size_int_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extend           </td>
          <td>(</td>
          <td class="paramtype">const size_int_t&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extends the container <b>by</b> count members. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>= the count of items we want to add to the container</td></tr>
  </table>
</dl>
Its running time is <em>O(n)</em>, where <em>n</em> is a number of items stored in the container. 
<p>Referenced by <a class="el" href="dve__process_8cc-source.html#l00082">dve_process_t::add_assertion()</a>, <a class="el" href="dve__process_8cc-source.html#l00061">dve_process_t::add_state()</a>, and <a class="el" href="dve__expression_8cc-source.html#l00242">dve_expression_t::dve_expression_t()</a>.</p>

</div>
</div><p>
<a class="anchor" name="c88da080a0faf84f35473285eed38b26"></a><!-- doxytag: member="array_t::extend_to" ref="c88da080a0faf84f35473285eed38b26" args="(const size_int_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extend_to           </td>
          <td>(</td>
          <td class="paramtype">const size_int_t&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extends the container to the size of `count' elements. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Important: This method presumes, that <em>count</em> &gt;= <a class="el" href="classarray__t.html#2216cf611d64e85907f4a64977f251e1" title="Returns a count of items stored in a container.">size()</a>.</dd></dl>
Its running time is <em>O(n)</em>, where <em>n</em> is a number of items stored in the container. 
</div>
</div><p>
<a class="anchor" name="58a09d8ac91970e7eec713b6dcbd42f7"></a><!-- doxytag: member="array_t::get_alloc_step" ref="58a09d8ac91970e7eec713b6dcbd42f7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_int_t get_alloc_step           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an allocation step. 
<p>
Returns an allocation step. Allocation step is the least step of allocation of new items (we always allocate the number of items, which is divisible by <a class="el" href="classarray__t.html#58a09d8ac91970e7eec713b6dcbd42f7" title="Returns an allocation step.">get_alloc_step()</a>) 
<p>Referenced by <a class="el" href="array_8hh-source.html#l00102">array_t&lt; dve_symbol_t * &gt;::assign_from()</a>.</p>

</div>
</div><p>
<a class="anchor" name="4fd2c8aafffc98cd5cd8be9edb49790d"></a><!-- doxytag: member="array_t::get_allocated" ref="4fd2c8aafffc98cd5cd8be9edb49790d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_int_t get_allocated           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a count of items allocated in a memory of this container. 
<p>
Returns a count of items allocated in a memory of this container. It's return value is always more or equal to return value of <a class="el" href="classarray__t.html#2216cf611d64e85907f4a64977f251e1" title="Returns a count of items stored in a container.">size()</a> 
<p>Referenced by <a class="el" href="array_8hh-source.html#l00102">array_t&lt; dve_symbol_t * &gt;::assign_from()</a>.</p>

</div>
</div><p>
<a class="anchor" name="bb8e6ce01e2629c199ffc9405bba2a7c"></a><!-- doxytag: member="array_t::last" ref="bb8e6ce01e2629c199ffc9405bba2a7c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray__t.html#2fc97dce62b7053449cc868607540dba">const_iterator</a> last           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a constant iterator pointing to the last item of the container. 
<p>
It is really fast operation running in time <em>O(1)</em> 
</div>
</div><p>
<a class="anchor" name="4f73d0c8e4ea8066dbc54a6a63330252"></a><!-- doxytag: member="array_t::last" ref="4f73d0c8e4ea8066dbc54a6a63330252" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray__t.html#35c955cacac6aacaa1e82874b1628865">iterator</a> last           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an iterator pointing to the last item of the container. 
<p>
It is really fast operation running in time <em>O(1)</em> 
</div>
</div><p>
<a class="anchor" name="73649441c9e19846aa9da9a2b214e03e"></a><!-- doxytag: member="array_t::pop_back" ref="73649441c9e19846aa9da9a2b214e03e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T pop_back           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the last item from the container. 
<p>
Removes the last item from the container and returns its value. It doesn't relesase the memory allocated for the last item (this memory will be reused in the next <a class="el" href="classarray__t.html#6ca947f3c87573111ff4a96a97042477" title="Appends `what&#39; to the end of the container.">push_back()</a>) - therefore it runs in a time <em>O(1)</em> and it it really fast operation. 
</div>
</div><p>
<a class="anchor" name="6ca947f3c87573111ff4a96a97042477"></a><!-- doxytag: member="array_t::push_back" ref="6ca947f3c87573111ff4a96a97042477" args="(T what)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void push_back           </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>what</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Appends `what' to the end of the container. 
<p>
Appends <em>what</em> to the end of the container. If neccessary it extends the allocated memory. Therefore in that case it runs in a time<em>O(n)</em>, where <em>n</em> is a number of items stored in the container. 
<p>Referenced by <a class="el" href="dve__symbol__table_8cc-source.html#l00010">dve_symbol_table_t::add_channel()</a>, <a class="el" href="dve__prob__process_8cc-source.html#l00024">dve_prob_process_t::add_prob_transition()</a>, <a class="el" href="dve__system_8cc-source.html#l00237">dve_system_t::add_process()</a>, <a class="el" href="dve__symbol__table_8cc-source.html#l00021">dve_symbol_table_t::add_process()</a>, <a class="el" href="dve__symbol__table_8cc-source.html#l00047">dve_symbol_table_t::add_state()</a>, <a class="el" href="dve__process_8cc-source.html#l00061">dve_process_t::add_state()</a>, <a class="el" href="dve__process_8cc-source.html#l00071">dve_process_t::add_transition()</a>, <a class="el" href="dve__symbol__table_8cc-source.html#l00033">dve_symbol_table_t::add_variable()</a>, <a class="el" href="por_8cc-source.html#l01015">por_t::ample_set_succs()</a>, <a class="el" href="dve__explicit__system_8cc-source.html#l01216">dve_explicit_system_t::compute_successors_without_sync()</a>, <a class="el" href="prob__system_8cc-source.html#l00008">prob_system_t::consolidate()</a>, <a class="el" href="dve__explicit__system_8cc-source.html#l00835">dve_explicit_system_t::get_async_enabled_trans_succs()</a>, <a class="el" href="dve__prob__explicit__system_8cc-source.html#l00007">dve_prob_explicit_system_t::get_succs()</a>, <a class="el" href="dve__explicit__system_8cc-source.html#l00914">dve_explicit_system_t::get_sync_enabled_trans_succs()</a>, and <a class="el" href="dve__explicit__system_8cc-source.html#l01024">dve_explicit_system_t::get_sync_succs_internal()</a>.</p>

</div>
</div><p>
<a class="anchor" name="9821feac13831e832c3447a3a333a9f9"></a><!-- doxytag: member="array_t::resize" ref="9821feac13831e832c3447a3a333a9f9" args="(const size_int_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void resize           </td>
          <td>(</td>
          <td class="paramtype">const size_int_t&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resizes the container to the size of `count' elements. 
<p>
It is implemented using <a class="el" href="classarray__t.html#d0e444e6c65888495eec136774166dc7" title="Shrinks the container to the size of `count&#39; elements.">shrink_to()</a> and <a class="el" href="classarray__t.html#c88da080a0faf84f35473285eed38b26" title="Extends the container to the size of `count&#39; elements.">extend_to()</a> methods. Therefore if <em>count</em> &lt;= <a class="el" href="classarray__t.html#2216cf611d64e85907f4a64977f251e1" title="Returns a count of items stored in a container.">size()</a> it runs in a time <em>O(1)</em> (it uses <a class="el" href="classarray__t.html#d0e444e6c65888495eec136774166dc7" title="Shrinks the container to the size of `count&#39; elements.">shrink_to()</a> method), otherwise it runs in a time <em>O(n)</em> (it uses <a class="el" href="classarray__t.html#c88da080a0faf84f35473285eed38b26" title="Extends the container to the size of `count&#39; elements.">extend_to()</a> method), where <em>n</em> is a number of items stored in the container. 
<p>Referenced by <a class="el" href="dve__expression_8cc-source.html#l00277">dve_expression_t::assign()</a>, and <a class="el" href="prob__transition_8cc-source.html#l00023">prob_transition_t::set_trans_count()</a>.</p>

</div>
</div><p>
<a class="anchor" name="643855ce67fbf1d69755427f63acc2bf"></a><!-- doxytag: member="array_t::set_alloc_step" ref="643855ce67fbf1d69755427f63acc2bf" args="(const size_int_t new_alloc_step)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_alloc_step           </td>
          <td>(</td>
          <td class="paramtype">const size_int_t&nbsp;</td>
          <td class="paramname"> <em>new_alloc_step</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets an alloc_step step. 
<p>
Sets an allocation step. Allocation step is the least step of allocation of new items (we always allocate the number of items, which is divisible by <a class="el" href="classarray__t.html#58a09d8ac91970e7eec713b6dcbd42f7" title="Returns an allocation step.">get_alloc_step()</a>) 
</div>
</div><p>
<a class="anchor" name="d0e444e6c65888495eec136774166dc7"></a><!-- doxytag: member="array_t::shrink_to" ref="d0e444e6c65888495eec136774166dc7" args="(const size_int_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void shrink_to           </td>
          <td>(</td>
          <td class="paramtype">const size_int_t&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shrinks the container to the size of `count' elements. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Important: This method presumes, that <em>count</em> &lt;= <a class="el" href="classarray__t.html#2216cf611d64e85907f4a64977f251e1" title="Returns a count of items stored in a container.">size()</a>.</dd></dl>
Its running time is <em>O(1)</em> and it is really fast operation 
</div>
</div><p>
<a class="anchor" name="a0233442c8a81e376c9aa0e7f43b277e"></a><!-- doxytag: member="array_t::swap" ref="a0233442c8a81e376c9aa0e7f43b277e" args="(array_t&lt; T, Alloc &gt; &amp;second)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarray__t.html">array_t</a>&lt; T, Alloc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>second</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps the containment of instance `second' and this. 
<p>
Swaps the containment of instance `second' and this. On one hand (unlike <a class="el" href="classarray__t.html#bbf40a10f7a4adf7a296830bb09f8e2f" title="Copies `to_copy&#39; to this container.">assign_from()</a>) it changes its parameter, but on the other hand it runs only in <em>O(1)</em> time, what is much faster than the running time of <a class="el" href="classarray__t.html#bbf40a10f7a4adf7a296830bb09f8e2f" title="Copies `to_copy&#39; to this container.">assign_from()</a> 
<p>Referenced by <a class="el" href="dve__expression_8cc-source.html#l00304">dve_expression_t::swap()</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="array_8hh-source.html">array.hh</a></ul>
</div>

<hr size="1"><small><img align="center" src="divine_mini.gif"><b> Reference Manual for Library, 2006 developed in <a href="http://www.fi.muni.cz/paradise/">ParaDiSe</a> laboratory, <a href="http://www.fi.muni.cz/">Faculty of Informatics</a>, <a href="http://www.muni.cz/">Masaryk University</a></b></small>
</body>
</html>


