<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>DiVinE: message_t Class Reference</title>
<link href="main.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>message_t Class Reference</h1><!-- doxytag: class="message_t" -->Class representing a data to send or receive using <a class="el" href="classnetwork__t.html" title="Network communication support class.">network_t</a>.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="message_8hh-source.html">message.hh</a>&gt;</code>
<p>

<p>
<a href="classmessage__t-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#398845fd34929f8f1bbde83d5d50d6a3">append_bool</a> (const bool flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a flag to the message.  <a href="#398845fd34929f8f1bbde83d5d50d6a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4e4ffe27c3b70df4c3dea5ab61580f40"></a><!-- doxytag: member="message_t::append_byte" ref="4e4ffe27c3b70df4c3dea5ab61580f40" args="(const byte_t number)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#4e4ffe27c3b70df4c3dea5ab61580f40">append_byte</a> (const byte_t number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a number of type byte_t to the message. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#a74ff04e96a71d047a19bb126235ad9b">append_data</a> (const byte_t *const data_to_copy, const size_int_t size_to_copy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes `size_to_copy' bytes from `data_to_copy' to the message.  <a href="#a74ff04e96a71d047a19bb126235ad9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="78b725b894963851276f9fd74f5d7eeb"></a><!-- doxytag: member="message_t::append_sbyte" ref="78b725b894963851276f9fd74f5d7eeb" args="(const sbyte_t number)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#78b725b894963851276f9fd74f5d7eeb">append_sbyte</a> (const sbyte_t number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a number of type sbyte_t to the message. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="589def7c509fbd3acf4c60ae890a3c39"></a><!-- doxytag: member="message_t::append_size_int" ref="589def7c509fbd3acf4c60ae890a3c39" args="(const size_int_t number)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#589def7c509fbd3acf4c60ae890a3c39">append_size_int</a> (const size_int_t number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a number of type size_int_t to the message. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4b1b3572b58f87e915f60864b7174a7a"></a><!-- doxytag: member="message_t::append_slong_int" ref="4b1b3572b58f87e915f60864b7174a7a" args="(const slong_int_t number)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#4b1b3572b58f87e915f60864b7174a7a">append_slong_int</a> (const slong_int_t number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a number of type slong_int_t to the message. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cfc0a8a5380d234974f79cc9c5ff84b1"></a><!-- doxytag: member="message_t::append_sshort_int" ref="cfc0a8a5380d234974f79cc9c5ff84b1" args="(const sshort_int_t number)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#cfc0a8a5380d234974f79cc9c5ff84b1">append_sshort_int</a> (const sshort_int_t number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a number of type sshort_int_t to the message. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#2c0d866a26ff8b25b5f11f13d2e67cb9">append_state</a> (const <a class="el" href="structstate__t.html">state_t</a> state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a complete representation of state to the message.  <a href="#2c0d866a26ff8b25b5f11f13d2e67cb9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3cb0fea3d51bcaed996ad821b30f1a3c"></a><!-- doxytag: member="message_t::append_state_ref" ref="3cb0fea3d51bcaed996ad821b30f1a3c" args="(const state_ref_t state_ref)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#3cb0fea3d51bcaed996ad821b30f1a3c">append_state_ref</a> (const <a class="el" href="classstate__ref__t.html">state_ref_t</a> state_ref)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a state reference `state_ref' to the message. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="647cef793f19e38924a454ed2039a89d"></a><!-- doxytag: member="message_t::append_ulong_int" ref="647cef793f19e38924a454ed2039a89d" args="(const ulong_int_t number)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#647cef793f19e38924a454ed2039a89d">append_ulong_int</a> (const ulong_int_t number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a number of type ulong_int_t to the message. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0bb142af56d8df744b54caecb620e53d"></a><!-- doxytag: member="message_t::append_ushort_int" ref="0bb142af56d8df744b54caecb620e53d" args="(const ushort_int_t number)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#0bb142af56d8df744b54caecb620e53d">append_ushort_int</a> (const ushort_int_t number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a number of type ushort_int_t to the message. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="94dfed5023230d094d9871e66374fce7"></a><!-- doxytag: member="message_t::get_allocated_size" ref="94dfed5023230d094d9871e66374fce7" args="() const " -->
size_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#94dfed5023230d094d9871e66374fce7">get_allocated_size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a size of byte sequence representing a message. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="01023ccc805756d92cd2d5f21a4dd962"></a><!-- doxytag: member="message_t::get_data" ref="01023ccc805756d92cd2d5f21a4dd962" args="() const " -->
const byte_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#01023ccc805756d92cd2d5f21a4dd962">get_data</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a stored byte sequence representing a message. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="05b7db10930a860f0778fbd6d0db84d0"></a><!-- doxytag: member="message_t::get_data" ref="05b7db10930a860f0778fbd6d0db84d0" args="()" -->
byte_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#05b7db10930a860f0778fbd6d0db84d0">get_data</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a stored byte sequence representing a message. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_int_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#61c9a9dfc188ced02a6f3fd3da5fb7ca">get_written_size</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#ad5f75aaff5bd73e06991480b5ed1ee1">load_data</a> (byte_t *const new_data, const size_int_t new_allocated_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces a data in a message by given data (using memory copying).  <a href="#ad5f75aaff5bd73e06991480b5ed1ee1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#13361ab33fec19779c709935fca01311">message_t</a> (const size_int_t number_of_preallocated_bytes=1024, const size_int_t reallocation_step=1024)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A constructor.  <a href="#13361ab33fec19779c709935fca01311"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7e3946a166e72b965e017905adc430d0"></a><!-- doxytag: member="message_t::read_bool" ref="7e3946a166e72b965e017905adc430d0" args="(bool &amp;flag)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#7e3946a166e72b965e017905adc430d0">read_bool</a> (bool &amp;flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a flag from the message to `flag'. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dbd1e17464067ed32e8f2d707cfa297b"></a><!-- doxytag: member="message_t::read_byte" ref="dbd1e17464067ed32e8f2d707cfa297b" args="(byte_t &amp;number)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#dbd1e17464067ed32e8f2d707cfa297b">read_byte</a> (byte_t &amp;number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a number of type byte_t to `number'. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#033e2f1d07caf6e71dfdbb760acb4695">read_data</a> (char *const data_to_copy, const std::size_t size_to_copy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies `size_to_copy' bytes from the message to `data_to_copy'.  <a href="#033e2f1d07caf6e71dfdbb760acb4695"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9b3513cafd47ac94d8ca2f9f346f01c8"></a><!-- doxytag: member="message_t::read_sbyte" ref="9b3513cafd47ac94d8ca2f9f346f01c8" args="(sbyte_t &amp;number)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#9b3513cafd47ac94d8ca2f9f346f01c8">read_sbyte</a> (sbyte_t &amp;number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a number of type sbyte_t to `number'. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d587e039c3c1c3c230d46c00286aeb22"></a><!-- doxytag: member="message_t::read_size_int" ref="d587e039c3c1c3c230d46c00286aeb22" args="(size_int_t &amp;number)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#d587e039c3c1c3c230d46c00286aeb22">read_size_int</a> (size_int_t &amp;number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a number of type size_int_t to `number'. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1b9865325ffeda5115de2188c3d0775a"></a><!-- doxytag: member="message_t::read_slong_int" ref="1b9865325ffeda5115de2188c3d0775a" args="(slong_int_t &amp;number)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#1b9865325ffeda5115de2188c3d0775a">read_slong_int</a> (slong_int_t &amp;number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a number of type slong_int_t to `number'. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6d7c1f07f7754ac6a99f8f7e9229f3bd"></a><!-- doxytag: member="message_t::read_sshort_int" ref="6d7c1f07f7754ac6a99f8f7e9229f3bd" args="(sshort_int_t &amp;number)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#6d7c1f07f7754ac6a99f8f7e9229f3bd">read_sshort_int</a> (sshort_int_t &amp;number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a number of type sshort_int_t to `number'. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#f44d51f977ecf43d8824d827313be775">read_state</a> (<a class="el" href="structstate__t.html">state_t</a> &amp;state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a state stored in the message to `state'.  <a href="#f44d51f977ecf43d8824d827313be775"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5c81f61feee808bf9b8284c2245a5af"></a><!-- doxytag: member="message_t::read_state_ref" ref="a5c81f61feee808bf9b8284c2245a5af" args="(state_ref_t &amp;ref)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#a5c81f61feee808bf9b8284c2245a5af">read_state_ref</a> (<a class="el" href="classstate__ref__t.html">state_ref_t</a> &amp;ref)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a reference to state stored in the message to `ref'. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f725c739ada783bcd287b3187fe0ddfe"></a><!-- doxytag: member="message_t::read_ulong_int" ref="f725c739ada783bcd287b3187fe0ddfe" args="(ulong_int_t &amp;number)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#f725c739ada783bcd287b3187fe0ddfe">read_ulong_int</a> (ulong_int_t &amp;number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a number of type ulong_int_t to `number'. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0ef70279335a8341b06f7fc1afb15923"></a><!-- doxytag: member="message_t::read_ushort_int" ref="0ef70279335a8341b06f7fc1afb15923" args="(ushort_int_t &amp;number)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#0ef70279335a8341b06f7fc1afb15923">read_ushort_int</a> (ushort_int_t &amp;number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a number of type ushort_int_t to `number'. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#b8734e666421c9fe3b6380a818c6c727">rewind</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves both reading and writting heads to the beginning of the message.  <a href="#b8734e666421c9fe3b6380a818c6c727"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#86c6a6ddfc9fd4a02fe53601818e9d72">rewind_append</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves a writting head to the beginning of the message.  <a href="#86c6a6ddfc9fd4a02fe53601818e9d72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#804e0deac3075d205df87ad871e9dc9a">rewind_read</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves a reading head to the beginning of the message.  <a href="#804e0deac3075d205df87ad871e9dc9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#2a56505337358759d8ea015105cab8f0">set_data</a> (byte_t *const new_data, const size_int_t new_allocated_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a byte sequence stored in a message.  <a href="#2a56505337358759d8ea015105cab8f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#ee937e8bff40ae909acd258cf54a4ca5">set_data</a> (byte_t *const new_data, const size_int_t new_allocated_size, const size_int_t new_written_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a byte sequence stored in a message.  <a href="#ee937e8bff40ae909acd258cf54a4ca5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#edcaa0ef5c3055be3a4cc94dc995d1a2">set_written_size</a> (const size_int_t new_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a size of written part of message.  <a href="#edcaa0ef5c3055be3a4cc94dc995d1a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmessage__t.html#a3ed16bb05e10c16c03cf18d5d4cfa2a">~message_t</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A destructor.  <a href="#a3ed16bb05e10c16c03cf18d5d4cfa2a"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class representing a data to send or receive using <a class="el" href="classnetwork__t.html" title="Network communication support class.">network_t</a>. 
<p>
This class is good for sending or receiving of messages consisting of several items (of possibly various types). It supports a transmission of basic integer types, states, state references and general sequences of bytes.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>This class implicitly allocates 4096 B. It is not good idea to have 1000000 instances of it or to create and destroy its instances many times. It is presumed, that in a program there will be only few "global" instances shared by all sending and receiving procedures. </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="13361ab33fec19779c709935fca01311"></a><!-- doxytag: member="message_t::message_t" ref="13361ab33fec19779c709935fca01311" args="(const size_int_t number_of_preallocated_bytes=1024, const size_int_t reallocation_step=1024)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmessage__t.html">message_t</a>           </td>
          <td>(</td>
          <td class="paramtype">const size_int_t&nbsp;</td>
          <td class="paramname"> <em>number_of_preallocated_bytes</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_int_t&nbsp;</td>
          <td class="paramname"> <em>reallocation_step</em> = <code>1024</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>number_of_preallocated_bytes</em>&nbsp;</td><td>= a count of bytes to allocate for a byte sequence representing a message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reallocation_step</em>&nbsp;</td><td>= how much more bytes to allocate in case of reallocation </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a3ed16bb05e10c16c03cf18d5d4cfa2a"></a><!-- doxytag: member="message_t::~message_t" ref="a3ed16bb05e10c16c03cf18d5d4cfa2a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classmessage__t.html">message_t</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A destructor. 
<p>
It only deallocates a byte sequence stored in a message 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="398845fd34929f8f1bbde83d5d50d6a3"></a><!-- doxytag: member="message_t::append_bool" ref="398845fd34929f8f1bbde83d5d50d6a3" args="(const bool flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void append_bool           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>flag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a flag to the message. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Flag is stored to the single byte (not to sizeof(bool) bytes!) </dd></dl>

<p>References <a class="el" href="message_8cc-source.html#l00087">append_byte()</a>.</p>

</div>
</div><p>
<a class="anchor" name="a74ff04e96a71d047a19bb126235ad9b"></a><!-- doxytag: member="message_t::append_data" ref="a74ff04e96a71d047a19bb126235ad9b" args="(const byte_t *const data_to_copy, const size_int_t size_to_copy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void append_data           </td>
          <td>(</td>
          <td class="paramtype">const byte_t *const &nbsp;</td>
          <td class="paramname"> <em>data_to_copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_int_t&nbsp;</td>
          <td class="paramname"> <em>size_to_copy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes `size_to_copy' bytes from `data_to_copy' to the message. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data_to_copy</em>&nbsp;</td><td>= pointer to the sequence of bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size_to_copy</em>&nbsp;</td><td>= number of bytes to copy from the byte sequence given in <em>data_to_copy</em> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2c0d866a26ff8b25b5f11f13d2e67cb9"></a><!-- doxytag: member="message_t::append_state" ref="2c0d866a26ff8b25b5f11f13d2e67cb9" args="(const state_t state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void append_state           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstate__t.html">state_t</a>&nbsp;</td>
          <td class="paramname"> <em>state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a complete representation of state to the message. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>= state to copy to the message</td></tr>
  </table>
</dl>
Writes `state.size' and the byte sequence referenced by `state.ptr' to the message 
<p>References <a class="el" href="state_8hh-source.html#l00023">state_t::ptr</a>, and <a class="el" href="state_8hh-source.html#l00024">state_t::size</a>.</p>

</div>
</div><p>
<a class="anchor" name="61c9a9dfc188ced02a6f3fd3da5fb7ca"></a><!-- doxytag: member="message_t::get_written_size" ref="61c9a9dfc188ced02a6f3fd3da5fb7ca" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_int_t get_written_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a size of part of the message, where something has been written using append_* methods 
<p>Referenced by <a class="el" href="network_8cc-source.html#l01436">network_t::send_message()</a>, and <a class="el" href="network_8cc-source.html#l01447">network_t::send_urgent_message()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ad5f75aaff5bd73e06991480b5ed1ee1"></a><!-- doxytag: member="message_t::load_data" ref="ad5f75aaff5bd73e06991480b5ed1ee1" args="(byte_t *const new_data, const size_int_t new_allocated_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void load_data           </td>
          <td>(</td>
          <td class="paramtype">byte_t *const &nbsp;</td>
          <td class="paramname"> <em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_int_t&nbsp;</td>
          <td class="paramname"> <em>new_allocated_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replaces a data in a message by given data (using memory copying). 
<p>
Writes a given byte sequence to the begin of the message. The reading head in rewound to the begin of the message, writting head is moved to the end of new message content.<p>
Implemented simply as <code>this-&gt;<a class="el" href="classmessage__t.html#b8734e666421c9fe3b6380a818c6c727" title="Moves both reading and writting heads to the beginning of the message.">rewind()</a>; this-&gt;append_data(new_data, new_allocated_size);</code> 
</div>
</div><p>
<a class="anchor" name="033e2f1d07caf6e71dfdbb760acb4695"></a><!-- doxytag: member="message_t::read_data" ref="033e2f1d07caf6e71dfdbb760acb4695" args="(char *const data_to_copy, const std::size_t size_to_copy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_data           </td>
          <td>(</td>
          <td class="paramtype">char *const &nbsp;</td>
          <td class="paramname"> <em>data_to_copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&nbsp;</td>
          <td class="paramname"> <em>size_to_copy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies `size_to_copy' bytes from the message to `data_to_copy'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data_to_copy</em>&nbsp;</td><td>= the pointer to the byte sequence at least <em>data_to_copy</em> bytes long </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size_to_copy</em>&nbsp;</td><td>= count of bytes to copy from the message </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f44d51f977ecf43d8824d827313be775"></a><!-- doxytag: member="message_t::read_state" ref="f44d51f977ecf43d8824d827313be775" args="(state_t &amp;state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_state           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstate__t.html">state_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies a state stored in the message to `state'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>= the state which will be rewritten by the copy of state stored in the message</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>This method does not deallocate the byte sequence in state.ptr. This method allocated a new memory space and the user is reponsible for a deallocation of written state.ptr. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b8734e666421c9fe3b6380a818c6c727"></a><!-- doxytag: member="message_t::rewind" ref="b8734e666421c9fe3b6380a818c6c727" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rewind           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves both reading and writting heads to the beginning of the message. 
<p>
Then <a class="el" href="classmessage__t.html#61c9a9dfc188ced02a6f3fd3da5fb7ca">get_written_size()</a> will return 0, append_* methods will write from the beginning of the message and read_* methods will read from the beginning of the message Use this method if you do not care of the stored message and you want to write a new message to the same instance of this class. 
</div>
</div><p>
<a class="anchor" name="86c6a6ddfc9fd4a02fe53601818e9d72"></a><!-- doxytag: member="message_t::rewind_append" ref="86c6a6ddfc9fd4a02fe53601818e9d72" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rewind_append           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves a writting head to the beginning of the message. 
<p>
Then <a class="el" href="classmessage__t.html#61c9a9dfc188ced02a6f3fd3da5fb7ca">get_written_size()</a> will return 0 and append_* methods will write from the beginning of the message. Use this method if you do not care of the stored message and you want to write a new message to the same instance of this class. 
</div>
</div><p>
<a class="anchor" name="804e0deac3075d205df87ad871e9dc9a"></a><!-- doxytag: member="message_t::rewind_read" ref="804e0deac3075d205df87ad871e9dc9a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rewind_read           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves a reading head to the beginning of the message. 
<p>
Then all read_* methods will read from the beginning of the message 
</div>
</div><p>
<a class="anchor" name="2a56505337358759d8ea015105cab8f0"></a><!-- doxytag: member="message_t::set_data" ref="2a56505337358759d8ea015105cab8f0" args="(byte_t *const new_data, const size_int_t new_allocated_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_data           </td>
          <td>(</td>
          <td class="paramtype">byte_t *const &nbsp;</td>
          <td class="paramname"> <em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_int_t&nbsp;</td>
          <td class="paramname"> <em>new_allocated_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a byte sequence stored in a message. 
<p>
The same as <code>message_t::set_data(new_data,new_allocated_size,new_allocated_size) </code> <dl class="warning" compact><dt><b>Warning:</b></dt><dd>The byte sequence set by this method will be deallocated in a destructor! If you do not like this behavior, use a method <a class="el" href="classmessage__t.html#ad5f75aaff5bd73e06991480b5ed1ee1" title="Replaces a data in a message by given data (using memory copying).">load_data()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ee937e8bff40ae909acd258cf54a4ca5"></a><!-- doxytag: member="message_t::set_data" ref="ee937e8bff40ae909acd258cf54a4ca5" args="(byte_t *const new_data, const size_int_t new_allocated_size, const size_int_t new_written_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_data           </td>
          <td>(</td>
          <td class="paramtype">byte_t *const &nbsp;</td>
          <td class="paramname"> <em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_int_t&nbsp;</td>
          <td class="paramname"> <em>new_allocated_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_int_t&nbsp;</td>
          <td class="paramname"> <em>new_written_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a byte sequence stored in a message. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_data</em>&nbsp;</td><td>= byte sequence to store in a message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_allocated_size</em>&nbsp;</td><td>= size in bytes of the memory referenced by <em>new_data</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_written_size</em>&nbsp;</td><td>= the number of bytes, which are already written in the message (valid bytes) </td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The byte sequence set by this method will be deallocated in a destructor! If you do not like this behavior, use a method <a class="el" href="classmessage__t.html#ad5f75aaff5bd73e06991480b5ed1ee1" title="Replaces a data in a message by given data (using memory copying).">load_data()</a>. </dd></dl>

<p>Referenced by <a class="el" href="network_8cc-source.html#l02464">network_t::receive_message()</a>.</p>

</div>
</div><p>
<a class="anchor" name="edcaa0ef5c3055be3a4cc94dc995d1a2"></a><!-- doxytag: member="message_t::set_written_size" ref="edcaa0ef5c3055be3a4cc94dc995d1a2" args="(const size_int_t new_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_written_size           </td>
          <td>(</td>
          <td class="paramtype">const size_int_t&nbsp;</td>
          <td class="paramname"> <em>new_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a size of written part of message. 
<p>
It can be useful if you need to write a part of message directly to the memory referenced by <a class="el" href="classmessage__t.html#05b7db10930a860f0778fbd6d0db84d0" title="Returns a stored byte sequence representing a message.">get_data()</a>. 
<p>Referenced by <a class="el" href="network_8cc-source.html#l02464">network_t::receive_message()</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="message_8hh-source.html">message.hh</a><li>message.cc</ul>
</div>

<hr size="1"><small><img align="center" src="divine_mini.gif"><b> Reference Manual for Library, 2006 developed in <a href="http://www.fi.muni.cz/paradise/">ParaDiSe</a> laboratory, <a href="http://www.fi.muni.cz/">Faculty of Informatics</a>, <a href="http://www.muni.cz/">Masaryk University</a></b></small>
</body>
</html>


