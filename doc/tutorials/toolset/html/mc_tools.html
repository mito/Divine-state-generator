<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>DiVinE: Model Checking Tools</title>
<link href="styles.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">DiVinE Toolset</a>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="mc_tools">Model Checking Tools </a></h1>Currently there exist only LTL model checking algorithms and reachability analysis algorithms. Support for other logics is the future work.<p>
LTL is natively supported in both DVE and Promela modeling languages by possibility to add the never claim automaton to the source code of a model. This way the product automaton of a model and an LTL formula is created and the verification task reduces to accepting cycle detection.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For Promela we do not provide the possibility to generate the never claim automaton from an LTL formula. For DVE it is made using <code><a class="el" href="mm_tools.html#divinecombine">divine.combine</a></code></dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Distributed tools need to be run using utility <code>mpirun</code> from MPI distribution. This utility requires absolute path to the executable - E. g.</dd></dl>
<center> <code>mpirun -np 10 /usr/bin/divine.bledge peterson.dve</code> </center><h2><a class="anchor" name="reachability_analysis">
distr_reachability - Reachability Analysis</a></h2>
<h3><a class="anchor" name="reachability_analysis_synopsis">
Synopsis</a></h3>
<h3><a class="anchor" name="reachability_analysis_description">
Description</a></h3>
<h2><a class="anchor" name="neg_cycle_det">
negative_cycle_detection - Accepting Cycles Detected Using Negative Cycle Detection</a></h2>
<h3><a class="anchor" name="neg_cycle_det_synopsis">
Synopsis</a></h3>
[mpirun -np N] divine.negative_cycle_detection [-hS] [-H size] input_file<h3><a class="anchor" name="neg_cycle_det_description">
Description</a></h3>
LTL model checker based on the accepting cycle detection. Cycles are searched using a distributed algorithm for negative cycle detection. This approach was first published in <a href="http://citeseer.ist.psu.edu/470889.html">Distributed LTL Model Checking Based on Negative Cycle Detection (2001)</a><p>
<h3>Options</h3>
<p>
<ul>
<li>c, statelist ... produce a counterexample list of states</li><li>h, help ... print a brief help</li><li>t, trail ... produce a counterexample trail file (the list of transitions of the system)</li><li>H <code>x</code> ... set the size of hash table to <img class="formulaInl" alt="$\left\{\begin{array}{ll} 2^x &amp; \mbox{if } x<33 \\ x &amp; \mbox{if } x>=33 \end{array}\right.$" src="form_0.png"></li><li>L, log ... perform logging</li><li>S, printstats ... print statistics at the end of a computation</li><li>X <code>name</code>, basename <code>name</code> ... sets a base name of produced files to <code>name</code></li><li>Y, Z ... reserved for GUI</li></ul>
<p>
<h3>Output</h3>
<p>
If LTL formula is true, no accepting cycle is found, the message "<code>No accepting cycle found.</code>" is printed.<p>
If LTL formula is false, "<code>Accepting cycle found.</code>" is printed instead.<p>
If <code>-S/--printstats</code> parameter is set, the statistics is printed too:<ul>
<li>Runtime ... consumed time in seconds</li><li>Consumed memory ... sum of consumed memory on all workstations</li><li>Maximal memory on single computer ... maximum of consumed memory on single a workstation</li><li>Reached states ... number of mutually different generated states of the system</li><li>Size of the initial state ... number of bytes allocated for the initial state</li><li>Size of appendix ... size of additional data stored for each state</li><li>Used transitions ... number of performed transitions of the system</li><li>Number of walks to root ... number of amortized steps (see paper about the algorithm for details)</li><li>States returned to queue ... states sent to another workstation and returned back (see paper about the algorithm for details)</li><li>Number of updates of distances ... number of changes of a distance valuation of states (see paper about the algorithm for details)</li><li>Maximal height of amort. const. ... see paper about the algorithm for details</li><li>Maximal size of state queue ... maximal size of queue of states waiting for exploration (algorithm is BFS-based)</li></ul>
<p>
Furthermore if LTL formula is false and <code>-t/--trail</code> or <code>-c/--statelist</code> are set, then also special statistics for a counterexample is printed out:<ul>
<li>Runtime ... time additionally consumed for counterexample generation</li><li>Additionally consumed memory ... memory additionally consumed for a counterexample generation (sum of such memory on all workstations)</li><li>Maximal size of state queue ... maximal size of the state queue reached during a counterexample generation</li><li>Length of counterexample's cycle ... length of the cycle contained in a counterexample</li><li>Length of entire counterexample ... number of all states contained in a counterexample</li></ul>
<h2><a class="anchor" name="tbndfs">
token_based_ndfs - Token Based Nested DFS</a></h2>
<h3><a class="anchor" name="tbndfs_synopsis">
Synopsis</a></h3>
<h3><a class="anchor" name="tbndfs_description">
Description</a></h3>
LTL model checker based on the accepting cycle detection.<p>
Token based nested DFS algorithm performs a sequential computation in the distributed memory environment utilizing thus aggregate memory of participating workstations.<h2><a class="anchor" name="map">
distr_map - Accepting Cycles Detected Maximal Accepting Predecessor Function</a></h2>
<h3><a class="anchor" name="map_synopsis">
Synopsis</a></h3>
[mpirun -np N] divine.distr_map [-hS] [-H size] input_file<h3><a class="anchor" name="map_description">
Description</a></h3>
Distributed LTL model checker based on the accepting cycle detection. Cycles are detected by the recursively computed function &lt;it&gt;map&lt;/it&gt;: maximal accepting predecessor function. This approach was first published in <a href="http://www.cs.utexas.edu/users/hunt/FMCAD/2004/accepted/26.html">Accepting Predecessors are Better than Back Edges in Distributed LTL Model-Checking (2004)</a><p>
<h3>Options</h3>
<p>
<ul>
<li>c, statelist ... produce a counterexample list of states</li><li>h, help ... print a brief help</li><li>q, quiet ... quiet mode (do not print anything - overrides all except -h and -v)</li><li>r, report ... produce report (file.distr_map.report)</li><li>t, trail ... produce a counterexample trail file (the list of transitions of the system)</li><li>v, version ... shows program version</li><li>H <code>x</code> ... set the size of hash table to <img class="formulaInl" alt="$\left\{\begin{array}{ll} 2^x &amp; \mbox{if } x<33 \\ x &amp; \mbox{if } x>=33 \end{array}\right.$" src="form_0.png"></li><li>L, log ... perform logging</li><li>S, printstats ... print statistics at the end of a computation</li><li>X <code>name</code>, basename <code>name</code> ... sets a base name of produced files to <code>name</code></li><li>Y, Z ... reserved for GUI</li></ul>
<p>
<h3>Output</h3>
<p>
The number of iterations of the algorithm and the sizes of the set shrinkA after each iteration are printed (see the paper about algorithm for details).<p>
If LTL formula is true, no accepting cycle is found, the message "<code>Accepting cycle: NO.</code>" is printed.<p>
If LTL formula is false, "<code>Accepting cycle: YES.</code>" is printed.<p>
If <code>-S/--printstats</code> parameter is set, the statistics is printed too:<ul>
<li>Computation init ... time spent by the initialization of the computation</li><li>State size ... number of bytes allocated for a state</li><li>Appendix size ... size of additional data stored for each state</li><li>States generated ... number of mutually different generated states of the system</li><li>Hashtable size ... size of the hash table</li><li>Get_succs called ... total number of function <code>explicit_system_t::get_succs</code> callings</li><li>Trans. relaxed ... total number of relaxed (performed) transitions of the system</li><li>All memory used ... sum of consumed memory on all workstations</li><li>Computation done ... time spent by the whole computation </li></ul>
</div>
<hr size="1"><small><img align="center" src="divine_mini.gif"><b>Tutorial, 2006 developed in <a href="http://www.fi.muni.cz/paradise/">ParaDiSe</a> laboratory, <a href="http://www.fi.muni.cz/">Faculty of Informatics</a>, <a href="http://www.muni.cz/">Masaryk University</a></b></small>
</body>
</html>



