
// size of buffer K:
default(K, 3)
// loosy channels?
default(LOSS, 0)

channel toK, fromK, toL, fromL;
channel sRESET1, sRESET2, rRESET1, rRESET2,
	sRDY1, sRDY2, 
	sNOTRDY1, sNOTRDY2, 
	rDATA1, rDATA2,
	rNODATA1, rNODATA2;

//constants
//const byte RESET = 0;
//const byte RDY = 1;
//const byte NOTRDY = 2;
//const byte DATA = 3;
//const byte NODATA = 4;
//
//const byte tr = 8; // used for packing two values into one by bit shift

define(RESET, 0)
define(RDY,1)
define(NOTRDY, 2)
define(DATA, 3)
define(NODATA, 4)

define(tr, 8) // used for packing two values into one by bit shift


process Sender {
int n = -1, m;
state 	idle, ack_reset, reset, advance, N, E,
	q_i, q_e, q_n, q_a, q_error;
init idle;
trans
 idle -> ack_reset { sync sRESET1?; }, 
 idle -> q_i { sync sNOTRDY1?m; },
 idle -> q_a {sync sRDY1?m; },
 idle -> reset { sync rRESET1!;},
 
 ack_reset -> idle {sync rRESET1!; effect n = -1;},

 q_i -> idle { guard m == (n+1)%4; },
 q_i -> q_error { guard m != (n+1)%4; },

 reset -> reset {sync sNOTRDY1?m;},
 reset -> reset {sync sRDY1?m;},
 reset -> idle {sync sRESET1?; effect n = -1;},

 q_a -> advance { guard m == (n+1)%4; effect n = (n+1)%4;},
 q_a -> q_error { guard m != (n+1)%4;},

 advance -> N { sync rNODATA1!n; },
 advance -> E { sync rDATA1!n; },

 N -> reset { sync rRESET1!;},
 N -> ack_reset {sync sRESET1?;},
 N -> E {sync rDATA1!n;},
 N -> q_n { sync sRDY1?m;},
 q_n -> N {guard m==n; sync rDATA1!n; }, 
 q_n -> q_error {guard m!=n;},

 E -> reset { sync rRESET1!;},
 E -> ack_reset {sync sRESET1?;},
 E -> q_e {sync sNOTRDY1?m;},
 E -> q_e {sync sRDY1?m;},
 q_e -> E {guard m == n; sync rDATA1!n;},
 q_e -> advance {guard m == (n+1)%4; effect n = (n+1)%4; };
 
}

process Receiver {
int n, m;
state idle, ack_reset, reset, advance, N, E, q_i, q_e, q_n, q_a, q_error;
init idle;
 trans
 idle -> ack_reset { sync rRESET2?; },
 idle -> q_i { sync rNODATA2?m; },
 idle -> q_a { sync rDATA2?m;},
 idle -> reset { sync sRESET2!;},
 idle -> E {sync sRDY2!n;},

 ack_reset -> idle { sync sRESET2!; effect n = 0; },

 q_i -> idle { guard m==n;},
 q_i -> q_error {guard m!=n;},

 reset -> reset {sync rDATA2?m;},
 reset -> reset {sync rNODATA2?m;},
 reset -> idle {sync rRESET2?; effect n =0; },

 q_a -> advance {guard m == n; effect n = (n+1)%4;},
 q_a -> q_error {guard m != n;},

 advance -> N {sync sNOTRDY2!n;},
 advance -> E {sync sRDY2!n;},

 N -> reset {sync sRESET2!; },
 N -> ack_reset {sync rRESET2?;},
 N -> E { sync sRDY2!n;},
 N -> q_n {sync rDATA2?m;},
 q_n -> N { guard (m+1)%4 == n; sync sNOTRDY2!n;},
 q_n -> N { guard (m+1)%4 != n;},

 E -> reset { sync sRESET2!; },
 E -> ack_reset {sync rRESET2?;},
 E -> E { sync sRDY2!n;},
 E -> q_e { sync rDATA2?m;},
 q_e -> E { guard (m+1)%4 == n; sync sRDY2!n;},
 q_e -> advance {guard m == n;};

}

process StoR {
queue(buf, K)
byte n;
state q;
init q;
trans
 q -> q { guard not(full(buf)); sync rRESET1?; effect push(buf, RESET); },
 q -> q { guard not(full(buf)); sync rDATA1?n; effect push(buf, DATA + tr*n); },
 q -> q { guard not(full(buf)); sync rNODATA1?n; effect push(buf, NODATA + tr*n); },

 ifelse(LOSS,0, `', ` q -> q { guard not(empty(buf)); effect pop_front(buf); },')

 q -> q { guard not(empty(buf)) && front(buf) == RESET; sync rRESET2!; effect pop_front(buf); },
 q -> q { guard not(empty(buf)) && front(buf) % tr == DATA; sync rDATA2!(front(buf)/tr); effect pop_front(buf); },
 q -> q { guard not(empty(buf)) && front(buf) % tr == NODATA; sync rNODATA2!(front(buf)/tr); effect pop_front(buf); };
}

process RtoS {
queue(buf, K)
byte n;
state q;
init q;
trans
 q -> q { guard not(full(buf)); sync sRESET2?; effect push(buf, RESET); },
 q -> q { guard not(full(buf)); sync sRDY2?n; effect push(buf, RDY + tr*n); },
 q -> q { guard not(full(buf)); sync sNOTRDY2?n; effect push(buf, NOTRDY + tr*n); },

 ifelse(LOSS,0, `', ` q -> q { guard not(empty(buf)); effect pop_front(buf); },')

 q -> q { guard not(empty(buf)) && front(buf) == RESET; sync sRESET1!; effect pop_front(buf); },
 q -> q { guard not(empty(buf)) && front(buf) % tr == RDY; sync sRDY1!(front(buf)/tr); effect pop_front(buf); },
 q -> q { guard not(empty(buf)) && front(buf) % tr == NOTRDY; sync sNOTRDY1!(front(buf)/tr); effect pop_front(buf); };
}

system async;